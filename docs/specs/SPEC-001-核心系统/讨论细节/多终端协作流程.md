# 多终端协作流程 — 五方讨论结论

> 讨论时间：2026-02-20
> 参与方：架构师、人类替身PM、讨论专家、QA Lead、Tech Lead
> 轮次：5 轮

---

## 一、核心洞察

**"上下文连续性是零成本的"**：
- Opus 写完 SR，文件已在 context，写 AR 时直接引用
- Opus 写完 AR，设计已在 context，写代码时直接 Edit
- 另一个终端接手 = 重新 Read 文件 + 理解 AR + 对齐设计意图 = 纯浪费

**用户原话**："Opus 写完 AR 上下文全在手里，直接贴零开销。Sonnet 还要重建上下文，本质是高级复制粘贴。"

**类比**：Opus = SE/Senior 写 SR，实施终端 = 年轻员工/外包写 AR + 实施。SR 是"施工图纸"，不是"概念草图"。

---

## 二、三种执行模式

### 模式一：Opus 一条龙（默认）

**适用场景**：
- 单 Phase 开发
- 改动 ≤15 个文件
- Phase 之间有强依赖（如 P1.2 依赖 P1.1 的实施结果）

**流程**：
```
Opus-1: SR → AR（人类审批）→ 编码 → pytest → CR → P0/P1 归零 → ST
```

**SR 标准**：轻量级（可留 ≥50% 设计决策给实施阶段）

**优势**：零上下文切换，设计意图无损传递

**成本**：~$0.50/Phase

---

### 模式二：双 Opus 流水线（特定场景）

**适用场景**（满足任一即可）：
1. 多 Phase 流水线：≥3 个 Phase，依赖弱，可以设计与实施并行
2. 设计复用：一个 SR 可以拆分给多个实施方（如后端 + 前端）
3. 设计评审：人类需要深度参与设计，实施前充分对齐

**流程**：
```
Opus-1（设计终端）：
  SR-P1.1（30min）→ SR-P1.2（30min）→ SR-Phase2（30min）

人类（调度员）：
  开 Opus-2 → 指向 SR-P1.1 → 实施（2h）
  开 Opus-3 → 指向 SR-P1.2 → 实施（3h）
  开 Opus-4 → 指向 SR-Phase2 → 实施（4h）
```

**SR 标准**：完整设计蓝图（另一个 Opus 读完能直接开工）

必须包含：
- 改动文件清单（精确到文件路径）
- 每个文件的改动点（新增/修改/删除 + 函数签名 + 伪代码 ≤20 行）
- 接口契约（参数类型、返回值、异常处理）
- 依赖关系（改动顺序）
- 测试用例（输入 + 预期输出）
- 设计决策（为什么选 A 不选 B）

可以省略：
- 完整可运行的代码
- 变量命名、日志格式等琐碎细节

**优势**：设计不阻塞实施，总时间从串行压缩到并行（3 Phase 场景节省 ~40%）

**劣势**：人类成为调度瓶颈，心智开销增加 ~30%

**成本**：~$0.60/Phase（贵 20%，但并行省时间）

---

### 模式三：多终端并行（超大规模）

**适用场景**：
- 单 Phase 改动 >15 个文件
- 可以拆成多个独立模块（组间无强依赖）

**流程**：
```
Opus-1: SR（分析 + 拆分成 N 组）
  ↓
人类开 N 个 Opus 终端：
  Opus-2: 实施文件组 1
  Opus-3: 实施文件组 2
  Opus-N: 实施文件组 N
  ↓
Opus-1: 汇总 Code Review + ST
```

**SR 标准**：完整设计蓝图 + 模块拆分方案

---

## 三、决策树

```
开始
  ↓
单 Phase 还是多 Phase？
  ├─ 单 Phase
  │   ↓
  │   改动文件数？
  │   ├─ ≤15 文件 → 【模式一：Opus 一条龙】
  │   └─ >15 文件
  │       ↓
  │       可以拆成独立模块？
  │       ├─ 是 → 【模式三：多终端并行】
  │       └─ 否 → 【模式一：Opus 一条龙】（分批实施）
  │
  └─ 多 Phase
      ↓
      Phase 之间依赖关系？
      ├─ 强依赖（P1.2 依赖 P1.1 实施结果）
      │   → 【模式一：Opus 一条龙】（串行）
      └─ 弱依赖（只依赖接口定义，不依赖实施）
          ↓
          Phase 数量？
          ├─ ≤2 个 → 【模式一：Opus 一条龙】（串行，开销小）
          └─ ≥3 个
              ↓
              人类有足够终端资源？
              ├─ 是 → 【模式二：双 Opus 流水线】
              └─ 否 → 【模式一：Opus 一条龙】（串行）
```

**特殊场景**：
- 设计复用（一个 SR 给多个实施方）→ 模式二
- 设计评审（人类深度参与设计）→ 模式二

---

## 四、SR 标准对照表

| 维度 | 一条龙 SR（自己用） | 双 Opus SR（给另一个 Opus） |
|------|---------------------|---------------------------|
| 设计决策覆盖 | ≥50% | ≥80% |
| 伪代码长度 | ≤10 行/函数 | ≤20 行/函数 |
| 文件清单 | 可选 | 必须（精确到路径） |
| 测试用例 | 可选 | 必须（输入+预期输出） |
| 设计决策说明 | 可选 | 必须（为什么选 A 不选 B） |
| 验证标准 | Opus 自己能继续 | 另一个 Opus 读完能直接开工 |

---

## 五、人类参与点

| 卡点 | 模式一 | 模式二 | 模式三 |
|------|--------|--------|--------|
| SR 确认 | 可选 | 必须 | 必须 |
| AR 确认 | 必须 | N/A（Opus-2 自己写） | N/A |
| 开终端 | 不需要 | 每 Phase 一次 | 每模块一次 |
| 监控终端 | 1 个 | 2-4 个 | N+1 个 |
| ST 失败归因 | 连续失败 2 次介入 | 同左 | 同左 |

---

## 六、业界模式借鉴

| 框架 | 模式 | 我们借鉴的点 |
|------|------|-------------|
| MetaGPT | 角色固定流水线 + 产物驱动 | SR/AR 作为 Agent 间接口，不依赖对话 |
| SWE-bench | 单 Agent + 工具链 | Opus 一条龙，自主决策 |
| Devin | 单 Agent + 人类在环 | 卡点时主动请求人类决策 |
| AutoGPT | 任务队列驱动 | 任务看板自动流转（中期方案） |

---

## 七、任务看板驱动（中期方案）

**看板结构**：
```
Backlog          | In Progress      | Review           | Done
----------------|------------------|------------------|------------------
[ ] P1.2 设计    | [Opus-1] P1.1 SR | [待人类] P1.1 AR | [✓] M6 Phase0
[ ] Phase2 设计  |                  |                  |
```

**Agent 行为**：
1. 自动领取：空闲时从 Backlog 领取 → 移到 In Progress
2. 自动推进：SR 完成 → 移到 Review → 通知人类
3. 阻塞挂起：遇到设计决策 → 标记"待人类" → 去领下一个
4. 继续执行：人类批准 → 回到 In Progress → 继续编码

**人类只做三件事**：提需求、审 IR、审 AR

**技术实现**：复用现有 TaskCreate/TaskUpdate/TaskList

---

## 八、Sonnet 的定位

Sonnet 不适合做"实施方"（上下文重建成本 + 理解偏差风险）。

**Sonnet 的真正价值**：
1. 回归测试执行：Opus 改完代码后，Sonnet 并行跑全量回归
2. 盲测补盲区：不看 Opus 测试用例，独立产出边界场景
3. 批量机械操作：50 个 API 加同样日志
4. 测试用例 Review：审 Opus 写的测试，检查覆盖率盲区

---

## 九、分阶段落地

### 短期（M6 当前）
- 默认：Opus 一条龙
- 按需：人类手动开多终端 + 指向 SR

### 中期（M7 开始）
- 看板驱动 + 自动双 Opus
- Opus-1 写完 SR → 自动创建任务 → 空闲 Opus 自动领取

### 长期（M8+）
- 智能调度 + 自动拆分
- 系统自动分析 Phase 依赖 → 决定串行/并行
- Agent 自动领取 + 自动合并代码

---

## 十、未解决问题

1. **SR 质量保证**：如何保证双 Opus 模式下 SR 足够完整？当前靠人类审批，未来可加 checklist + Opus-2 理解确认
2. **设计意图丢失**：SR 文字描述无法 100% 传递"为什么这么设计"。当前靠 SR 必须包含设计决策章节
3. **人类调度瓶颈**：双 Opus 模式下人类手动开终端。未来靠看板自动分配
4. **依赖关系自动识别**：如何自动判断 Phase 间能否并行？当前靠人类手动标注
5. **多终端代码冲突**：并行改同一文件如何合并？当前靠人类在拆分时保证不冲突

---

## 十一、分支策略

一 Phase 一分支（`feature/m6-p1.1`），ST 通过后 merge main，下一个 Phase 从最新 main 拉分支。

P1.1/P1.2 串行（改同文件），Phase2 设计可并行。
